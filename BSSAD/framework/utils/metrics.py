import numpy as np
import math
from sklearn.metrics import roc_auc_score

def _calc_point2point(predict, actual):
    '''
        Parameters
        ----------
        predict (np.ndarray): predicted label
        actual (np.ndarray): actual label

        Returns
        -------
        f1 : F1 score
        prescision : Precision
        recall : Recall
        TP : True Positives 
        TN : True Negatives
        FP : False Positives
        FN : False Negatives
        auc : Area under ROC curve
        MCC : Matthew Correlation Coefficient 
    '''
    predict = np.array(predict)
    actual = np.array(actual)
#     print('predict',predict[:10])
#     print('acutal',actual[:10])
    TP = np.sum(predict * actual)
    TN = np.sum((1 - predict) * (1 - actual))
    FP = np.sum(predict * (1 - actual))
    FN = np.sum((1 - predict) * actual)
    precision = TP / (TP + FP + 0.00001)
    recall = TP / (TP + FN + 0.00001)
    f1 = 2 * precision * recall / (precision + recall + 0.00001)
    auc = roc_auc_score(actual, predict)
    #MCC = matthews_corrcoef(actual, predict)
    denom = (TP + FP)*(TP + FN)*(TN + FP)*(TN + FN)
    if denom > 0:
        MCC = (TP * TN - FP * FN)/math.sqrt(denom)
    else:
        MCC = 0
    #print("AUC: " + str(auc))
    #print("MCC: " + str(MCC))
    return f1, precision, recall, TP, TN, FP, FN, auc, MCC


def _adjust_predicts(score, label,
                    threshold=None,
                    pred=None,
                    calc_latency=False):
    '''
        Parameters
        ----------
        score (np.ndarray): The anomaly score
        label (np.ndarray): The ground-truth label
        threshold (float): The threshold of anomaly score.
            A point is labeled as "anomaly" if its score is lower than the threshold.
        pred (np.ndarray or None): if not None, adjust `pred` and ignore `score` and `threshold`,
        calc_latency (bool):

        Returns
        -------
         np.ndarray: predict labels
    '''
    if len(score) != len(label):
        raise ValueError("score and label must have the same length")
    score = np.asarray(score)
    label = np.asarray(label)
    latency = 0
    if pred is None:
        predict = score > threshold
    else:
        predict = pred
    actual = label > 0.1
    anomaly_state = False
    anomaly_count = 0
    for i in range(len(score)):
        if actual[i] and predict[i] and not anomaly_state:
                anomaly_state = True
                anomaly_count += 1
                for j in range(i, 0, -1):
                    if not actual[j]:
                        break
                    else:
                        if not predict[j]:
                            predict[j] = True
                            latency += 1
        elif not actual[i]:
            anomaly_state = False
        if anomaly_state:
            predict[i] = True
    if calc_latency:
        return predict, latency / (anomaly_count + 1e-4)
    else:
        return predict


def _calc_seq(score, label, threshold, calc_latency=False):
    '''
        Calculate f1 score for a score sequence
    '''
    if calc_latency:
        predict, latency = _adjust_predicts(score, label, threshold, calc_latency=calc_latency)
        t = list(_calc_point2point(predict, label))
        t.append(latency)
        return t
    else:
        predict = _adjust_predicts(score, label, threshold, calc_latency=calc_latency)
        return _calc_point2point(predict, label)


def bf_search(score, label, start, end=None, step_num=1, display_freq=1, verbose=True):
    '''
        Find the best-f1 score by searching best `threshold` in [`start`, `end`).

        Returns
        -------
        list : list for results
        float : the `threshold` for best-f1
    '''
    if step_num is None or end is None:
        end = start
        step_num = 1
    search_step, search_range, search_lower_bound = step_num, end - start, start
    if verbose:
        print("search range: ", search_lower_bound, search_lower_bound + search_range)
    threshold = search_lower_bound
    m = (-1., -1., -1.)
    m_t = 0.0
    for i in range(search_step):
        threshold += search_range / float(search_step)
        target = _calc_seq(score, label, threshold, calc_latency=True)
        if target[0] > m[0]:
            m_t = threshold
            m = target
        if verbose and i % display_freq == 0:
            print("cur thr: ", threshold, target, m, m_t)
    return m, m_t
